### Mysql 相关-索引

---

#### 普通索引和唯一索引

##### 查询过程 ： SELECT  id  FROM t WHERE  k = 5;

- **普通索引**：在索引树上搜索索引值为 5 的节点，找到之后，再继续向后搜索，直到找到第一个索引值不等于5的节点，然后返回
- **唯一索引**：在索引树上查找到第一个索引值为5的节点，直接返回

##### 更新过程

> change buffer  : 是一种特殊的数据结构，当二级索引的数据页不在 buffer pool 中，缓存二级索引的变更，缓存的通常是DML；同时，当之后发生读操作时或者定时的merge任务触发，这些变更会 merge 到buffer pool 中

- **唯一索引**：更新操作需要先判断是否违反唯一性约束，也就是先发生一次数据读到内存的操作；然后寻找插入位置，执行操作
- **普通索引**：如果插入的数据页在内存中，直接插入；当数据不在内存中时，将操作记录到`change buffer` ，结束；
- **结论**：对于普通索引而言，如果能够在 merge 动作之前，在`change buffer` 中记录尽可能多的操作，然后一次性merge 到 `buffer pool`，就会带来可观的收益，减少了磁盘 IO；也就意味着**写多读少**的场景，如果业务不要求唯一索引，可以使用普通索引来获得更高的插入性能

##### change buffer 和 redo log 

- 当更新一条不在内存中的数据记录，普通索引会记录更新操作到 `change buffer`，同时也会记录到 `redo log`；但是它们发挥的作用是不一样的，`change buffer`会减少随机读磁盘IO的操作，直接记录到内存；`redo log`则是通过顺序写操作，最终一次落盘，减少写磁盘IO的操作。 

---

#### 索引选择

- 从索引创建的角度来说，首先关注索引树的区分度，区分度越高，建立索引的收益就越大；
  - 假设考虑字段K是否建立索引，`SELECT COUNT(DISTINCT K) as total FROM T`，如果 total 值越接近 K 样本数，可以考虑
  - 如果是给字符类型字段建立前缀匹配，需要找出合适建立索引的前缀长度，`SELECT COUNT(DISTINCT LEFT(K,N)) FROM T` ，N 就是匹配的前缀长度
  - 如果是要求建立索引的字段前缀区分度较低，可以考虑建立倒排索引，或者通过`hash`函数计算字段的哈希值作为索引，同时需要判断字段值是否对应
- 但是，**前缀索引会导致覆盖索引失效**，需要回表查询数据行

