### Mysql 相关
>  数据库底层存储的核心都是基于数据模型的，先关注它的数据模型，才能从理论上分析出这个数据库的适用场景

---

#### 基本架构

- 

![白板](img\白板.jpg)



##### 一条SQL语句的执行过程

- **连接**：客户端通过各自的账号密码连接到SQL服务端
  - 如果连接数过多会导致内存飙升导致数据库OOM被，因此既要**限制创建的连接数**，也要**复用已有连接**
  
  - *show processonlist* 可以查看当前连接状态，默认由参数*wait_timeout* 控制连接断开的时间
  - Mysql 5.7 之后，想复用连接，可以通过 **mysql_reset_connection** 初始化连接资源，不需要重新鉴权
  
-  **鉴权**：预先校验当前用户是否有访问目标表或者执行目标操作的权限
  - 无权访问表或者无权执行操作
- **查询缓存**：如果表开启了查询缓存，优先命中缓存会直接返回结果
  - 表的**更新语句**会导致该表的查询缓存失效，因此写多读少的表不适合开启查询缓存
  - ***MYSQL8.0 删除了这个功能***
- **分析器**：进行词法分析和语法分析
  - 这一部分进行的工作是将SQL语句按照规则分析是否合法
  - 如果**访问了表不存在的字段**，也会在这一阶段提示错误，而不是在执行阶段
- **优化器**：生成执行计划，选择最佳索引
  - 执行计划表示当前语句的执行成本等信息：扫描行数，是否使用了索引，连接表信息等
  - 也可以通过 *EXPLAIN* 关键字查看一条语句的执行计划
  - 多表连接查询会决定最优的连接顺序
  - 表存在多个索引也会决定使用最佳索引执行



---

#### Mysql 更新语句执行过程

##### Redo Log 和 Binlog 

- Mysql 数据最终会持久化到磁盘，但是磁盘IO的效率相对内存是很低的，因此如果每次执行更新语句都直接落盘会导致效率低下；
- 解决的办法就是先**快速**记录需要执行的更新语句，然后某一时刻统一落盘
- 这个过程在Mysql 中就是**先写 Redo Log**， 这是属于 InnoDB 引擎独有的
  - InnoDB Redo Log 是固定大小为 1GB，它记录的是执行的操作：给名为 admin 的用户修改别名叫 tom 
  - 可以类比为一个**环形数组**，从头部**write_position** 开始写入，**check_point** 将该位置更新到 Binlog ，然后擦除，写入新数据
  - 可以简单理解为具有头尾指针的数组，如果头指针追上了尾指针，复位到起始位置循环 写
- Server 层则是对应有 **Binlog** ，与 RedoLog 不同，binlog 是追加写，写满自动切换下一个文件，不会覆盖
- **执行过程**：
  - 执行器查找ID=2 的行，从内存加载或者从磁盘加载再写入到内存
  - 执行器对数据行进行操作，例如 N -> N+1
  - 引擎将数据更新到内存，同时记录redo log ，此时 redo log 的记录处于 **prepare** 状态（事务未提交）
  -  执行其生成这个操作的 binlog ，并落盘
  - 执行器调用引擎的提交事务接口，引擎把 redo log 状态更新为 **commit** ，更新完成
  - 写 redo log 的 prepare -> commit  过程，是两阶段的提交



---

#### 事务

##### 基本特性

- 原子性：**Atomicity** ，事务操作不可拆分
- 一致性：**Consistency**，事务开始之前和执行之后，不会破坏数据库的完整性，写入资料符合预设约束
- 隔离性：**Isolation** ，允许多个事务并发进行读写修改，根据隔离级别控制事务数据之间的访问
- 持久性：**Durability**，事务执行成功，写入数据就是永久的

##### 隔离性

###### 隔离级别

- **read uncommited**：读未提交，事务未提交时的变更也可以被其他事务读取到
  - 可能导致脏读，不可重复读，幻读
- **read commited**：读已提交，事务提交之后，才可以被其他事务读取到自身的修改
  - 可能导致不可重读
- **repeatable read**：可重复读，事务执行期间看到的数据和事务启动时看到的数据一致
  - 意味着事务以启动那一刻的数据快照为准，不会因为执行过程中其他事务的提交而读到新的数据结果
- **serializable**：串行化，读写操作都会加锁，事务顺序执行，不允许并发事务



###### 事务隔离的实现 - TODO

- 当前读
- 快照读
- MVCC



---

#### 索引
- **是什么？**
    - 为了加快数据查询速度的一种数据结构
    - 以N叉树的形式存储，主键索引路径节点存储主键ID，叶子节点存储数据行，同时为了维持范围查询的速度，叶子节点还维护了指向相邻节点的引用，因此主键索引也叫聚簇索引；
    - 非主键索引称为*二级索引*，叶子节点维护的主键所在的位置，然后再通过主键查找所在的数据行，这个过程也叫做回表
    - 回表会导致多一次查询过程，解决的这个问题可以考虑建立联合索引，在索引覆盖查询数据的情况下，可以直接通过索引表查到所需的数据（例如建立name,address,email 的联合索引，SELECT address,email WHERE name = 'test' 就可以直接通过查询索引表获得目标数据 ），这个过程也叫**索引下推**

- **InnoDB的索引模型**
    - 表根据主键顺序以索引形式存放的，这种存储方式的表称为索引组织表，数据都是存储在**B+树**中
    - **页分裂与页合并**：
        - B+树为了维护数据的有序性，在极端情况下，如果插入数据时当前页已满，需要重新申请一个页，并将插入位置之后的部分数据挪动到新的数据页，这个过程就是页分裂，性能会受到影响
        - 反之，由于删除数据重新调整树结构，会发生页合并
        - 关联问题分析：**自增主键的使用是绝对的吗？**
             - 使用自增主键的情况下，可以认为每次插入都是都是顺序追加，因此不会发生页分裂的情况；